load regras .

--- Commands to simplify meta-level commands usage

mod am7ll is
    protecting REGRAS .
    protecting META-LEVEL .

    *** Simplifações para os comandos de meta-level e tecnicas de parsing
	--- Disambiguation commands for each kind of usage:

    --- This one is used for meta-reduce equations
    op > <_> : SSequente -> String .
    
    --- This second, used for meta-rewrites simple REGRAS, which only needs one substitution
    op >> _ <_> <_&_> : Qid SSequente Contexto Contexto -> String .

    --- The last command, is used for rewrite complexe REGRAS, 'tensor right' and 'or multiplicative'
    --- which they need four substitutions
    op >>> _ <_> <_&_&_&_> : Qid SSequente Contexto Contexto Contexto Contexto -> String .
    
    --- These commands are implemented here. They are basically a simply command, with no verbose sintaxe,
    --- to do all the meta-level operation with replacements
    eq > < sequente:SSequente > =
        ParseSequente(downTerm(getTerm(metaReduce(upModule('am7ll, false), upTerm(sequente:SSequente))), error)) .

    eq >> regra:Qid < sequente:SSequente > < f:Contexto & g:Contexto > =
        ParseSequente(downTerm( getTerm( metaXapply( upModule( 'am7ll, false), upTerm(sequente:SSequente), 
        regra:Qid, 'F:Formula <- upTerm(f:Contexto) ; 'G:Formula <- upTerm(g:Contexto),
        0, unbounded, 0)), error)) .

    eq >>> regra:Qid < sequente:SSequente > < c:Contexto & d:Contexto & w:Contexto & z:Contexto > =
        ParseSequente(downTerm( getTerm( metaXapply ( upModule ('am7ll, false), upTerm(sequente:SSequente),
        regra:Qid, 'C:Contexto <- upTerm(c:Contexto) ; 'D:Contexto <- upTerm(d:Contexto) ;
        'W:Contexto <- upTerm(w:Contexto) ; 'Z:Contexto <- upTerm(z:Contexto),
        0, unbounded, 0)), error)) .

    --- Parsing methods used to split between the main operator and the rest
    op Main(_) : Contexto -> String .
    op Rest(_) : Contexto -> String .
    op ParseSequente(_) : SSequente -> String .

    --- Base case
    eq Main(p:Prop) = toString(p:Prop) .
    eq Rest(p:Prop) = toString(p:Prop) .

    --- Case of receiving a set of context or sequente. This one must be called on the last situation (other wise)
    eq Main( (C:Contexto, C':Contexto) ) = Main(C:Contexto) + ", " + Main(C':Contexto) [owise] .
    eq Rest( (C:Contexto, C':Contexto) ) = Rest(C:Contexto) + ", " + Rest(C':Contexto) [owise] .
    eq ParseSequente((S1:Sequente || S2:Sequente)) = ParseSequente(S1:Sequente) + " || " + ParseSequente(S2:Sequente) [owise] .

    --- Case of empty context
    eq Main(empty) = "" .
    eq Rest(empty) = "" .

    --- Other cases
    eq Main((F:Formula 8 G:Formula) ) = "PAR # ("    + Rest(F:Formula) + ") # ("  + Rest(G:Formula) + ")" .
    eq Main((F:Formula + G:Formula) ) = "PLUS # ("   + Rest(F:Formula) + ") # ("  + Rest(G:Formula) + ")" .
    eq Main((F:Formula & G:Formula) ) = "WITH # ("   + Rest(F:Formula) + ") # ("  + Rest(G:Formula) + ")" .
    eq Main((F:Formula x G:Formula) ) = "TENSOR # (" + Rest(F:Formula) + ") # ("  + Rest(G:Formula) + ")" .
    eq Main((F:Formula -o G:Formula)) = "LPOP # ("   + Rest(F:Formula) + ") # ("  + Rest(G:Formula) + ")" .
    eq Main( ! F:Formula )            = "BANG # ("   + Rest(F:Formula) + ")" .
    eq Main( ? F:Formula )            = "QMARK # ("  + Rest(F:Formula) + ")" .
    eq Main( ~ F:Formula )            = "NOT # ("    + Rest(F:Formula) + ")" .

    eq Rest((F:Formula 8 G:Formula) ) = "("          + Rest(F:Formula) + ") 8 ("  + Rest(G:Formula) + ")" .
    eq Rest((F:Formula + G:Formula) ) = "("          + Rest(F:Formula) + ") + ("  + Rest(G:Formula) + ")" .
    eq Rest((F:Formula & G:Formula) ) = "("          + Rest(F:Formula) + ") & ("  + Rest(G:Formula) + ")" .
    eq Rest((F:Formula x G:Formula) ) = "("          + Rest(F:Formula) + ") x ("  + Rest(G:Formula) + ")" .
    eq Rest((F:Formula -o G:Formula)) = "("          + Rest(F:Formula) + ") -o (" + Rest(G:Formula) + ")" .
    eq Rest( ! F:Formula )            = "!("         + Rest(F:Formula) + ")" .
    eq Rest( ? F:Formula )            = "?("         + Rest(F:Formula) + ")" .
    eq Rest( ~ F:Formula )            = "~("         + Rest(F:Formula) + ")" .
    
    eq ParseSequente( [C:Contexto] ; {D:Contexto} |-- [C':Contexto] ; {D':Contexto} ) =
        "[" + Main(C:Contexto)  + "] ; {" + Main(D:Contexto)  + "} |-- ["
            + Main(C':Contexto) + "] ; {" + Main(D':Contexto) + "}" .

endm

 
eof

red > < [p] ; {! p} |-- [empty] ; {(((a 8 b) + c) + (q 8 p)) 8 (p + (q 8 r))} > .

Exemplos

red > < [p] ; {! p} |-- [q] ; {r} > . 
red > < [p] ; {p + q} |-- [q] ; {a + t} > . 

red >> 'OrAddR2 < [p] ; {q} |-- [r] ; {s + t, u + t} > < s & t > .

red >> 'AndAddL1 < [empty] ; {q, r & s, t + u, r & q} |-- [empty] ; {a} > < r & q > .
red >> 'AndAddL1 < [empty] ; {q, r & s, t + u, r & s} |-- [empty] ; {a} > < r & s > .
red >> 'AndAddL2 < [empty] ; {q, r & s, t + u, r & s} |-- [empty] ; {a} > < r & s > .

red >>> 'TensorR < [t] ; {p, q} |-- [u] ; {t x a, b, c} > < p & q & c & b > .
red >>> 'TensorR < [t] ; {p, q} |-- [u] ; {t x a, b, c} > < p & q & b & c > .
red >>> 'TensorR < [t] ; {p, q} |-- [u] ; {t x a, b, c} > < q & p & c & b > .
red >>> 'TensorR < [t] ; {p, q} |-- [u] ; {t x a, (b + t), ( c + b)} > < q & p & (b + t) & (c + b) > .


red > < [t] ; {p, q} |-- [u] ; {t x a, b, c} > .



red >>> 'TensorR < [t] ; {p, (q 8 p)} |-- [u] ; {t x (a + ! (b x p)), b, ~ c} > < (q 8 p) & p & b & ~ c > .

red > < [empty] ; {p} |-- [empty] ; {p + q} > .

eq Main((F:Formula 8 G:Formula) )  = "PAR #( "      + Rest(F:Formula) + " 8 "  + Rest(G:Formula) + ")" .
eq Main((F:Formula + G:Formula) )  = "PLUS #( "     + Rest(F:Formula) + " + "  + Rest(G:Formula) + ")" .
eq Main((F:Formula & G:Formula) )  = "WITH #( "     + Rest(F:Formula) + " & "  + Rest(G:Formula) + ")" .
eq Main((F:Formula x G:Formula) )  = "TENSOR #( "   + Rest(F:Formula) + " x "  + Rest(G:Formula) + ")" .
eq Main((F:Formula -o G:Formula))  = "LPOP #( "     + Rest(F:Formula) + " -o " + Rest(G:Formula) + ")" .
eq Main( ! F:Formula )             = "BANG #(! "    + Rest(F:Formula) + ")" .
eq Main( ? F:Formula )             = "QMARK #(? "   + Rest(F:Formula) + ")" .
eq Main( ~ F:Formula )             = "NOT #(~ "     + Rest(F:Formula) + ")" .

eq Rest((F:Formula 8 G:Formula) )= "#( "          + Rest(F:Formula) + " 8 "  + Rest(G:Formula) + ")" .
eq Rest((F:Formula + G:Formula) )= "#( "          + Rest(F:Formula) + " + "  + Rest(G:Formula) + ")" .
eq Rest((F:Formula & G:Formula) )= "#( "          + Rest(F:Formula) + " & "  + Rest(G:Formula) + ")" .
eq Rest((F:Formula x G:Formula) )= "#( "          + Rest(F:Formula) + " x "  + Rest(G:Formula) + ")" .
eq Rest((F:Formula -o G:Formula))= "#( "          + Rest(F:Formula) + " -o " + Rest(G:Formula) + ")" .
eq Rest( ! F:Formula )           = "#! "         + Rest(F:Formula) + ")" .
eq Rest( ? F:Formula )           = "#(? "         + Rest(F:Formula) + ")" .
eq Rest( ~ F:Formula )           = "#(~ "         + Rest(F:Formula) + ")" .
    